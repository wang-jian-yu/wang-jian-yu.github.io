<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JDK1.8新特性 | Wang</title><meta name="description" content="内容的介绍 了解Java发展史 Lambda表达式 接口的增强 函数式接口 方法引用 Stream API Optional 新时间日期API 其他新特性  一、Java发展历史1. Java的发展历史 Sun公司在1991年成立了一个称为绿色计划( Green Project )的项目，由James Gosling(高斯林)博土领导，绿色计划的目的是开发一种能够在各种消费性电子产品(机顶盒、冰箱"><meta name="keywords" content="jdk"><meta name="author" content="小小王,1442243445@qq.com"><meta name="copyright" content="小小王"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Banq-1.ico"><link rel="canonical" href="http://yoursite.com/2022/01/16/jdk18/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="JDK1.8新特性"><meta property="og:url" content="http://yoursite.com/2022/01/16/jdk18/"><meta property="og:site_name" content="Wang"><meta property="og:description" content="内容的介绍 了解Java发展史 Lambda表达式 接口的增强 函数式接口 方法引用 Stream API Optional 新时间日期API 其他新特性  一、Java发展历史1. Java的发展历史 Sun公司在1991年成立了一个称为绿色计划( Green Project )的项目，由James Gosling(高斯林)博土领导，绿色计划的目的是开发一种能够在各种消费性电子产品(机顶盒、冰箱"><meta property="og:image" content="http://yoursite.com/img/bg5.jpg"><meta property="article:published_time" content="2022-01-16T03:28:24.000Z"><meta property="article:modified_time" content="2023-03-09T10:03:53.879Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="springclound" href="http://yoursite.com/2022/01/16/bk/"><link rel="next" title="MyBatisPlus" href="http://yoursite.com/2021/11/22/MyBatisPlus/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/move_mouse/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">73</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">51</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#内容的介绍"><span class="toc-number">1.</span> <span class="toc-text">内容的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Java发展历史"><span class="toc-number">1.1.</span> <span class="toc-text">一、Java发展历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java的发展历史"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1. Java的发展历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-OpenJDK和OracleJDK"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">2.OpenJDK和OracleJDK</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-Open-JDK来源"><span class="toc-number">1.1.0.2.0.1.</span> <span class="toc-text">2.1 Open JDK来源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-Open-JDK-和-Oracle-JDK的关系"><span class="toc-number">1.1.0.2.0.2.</span> <span class="toc-text">2.2 Open JDK 和 Oracle JDK的关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-Open-JDK-官网介绍"><span class="toc-number">1.1.0.2.0.3.</span> <span class="toc-text">2.3 Open JDK 官网介绍</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Lambda表达式"><span class="toc-number">1.2.</span> <span class="toc-text">二、Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-需求分析"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1. 需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Lambda表达式初体验"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2.Lambda表达式初体验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Lambda的语法规则"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">3. Lambda的语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-Lambda练习1"><span class="toc-number">1.2.0.3.0.1.</span> <span class="toc-text">3.1 Lambda练习1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-Lambda练习2"><span class="toc-number">1.2.0.3.0.2.</span> <span class="toc-text">3.2 Lambda练习2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-FunctionalInterface注解"><span class="toc-number">1.2.0.3.0.3.</span> <span class="toc-text">3.2 @FunctionalInterface注解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-Lambda表达式的原理"><span class="toc-number">1.2.0.3.0.4.</span> <span class="toc-text">3.3 Lambda表达式的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Lambda表达式的省略写法"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">4.Lambda表达式的省略写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Lambda表达式的使用前提"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">5.Lambda表达式的使用前提</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6-Lambda和匿名内部类的对比"><span class="toc-number">1.2.0.5.0.1.</span> <span class="toc-text">6.Lambda和匿名内部类的对比</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、接口中新增的方法"><span class="toc-number">1.3.</span> <span class="toc-text">三、接口中新增的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JDK8中接口的新增"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">1. JDK8中接口的新增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-默认方法"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">2.默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-为什么要增加默认方法"><span class="toc-number">1.3.0.2.0.1.</span> <span class="toc-text">2.1 为什么要增加默认方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-接口默认方法的格式"><span class="toc-number">1.3.0.2.0.2.</span> <span class="toc-text">2.2 接口默认方法的格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-接口中默认方法的使用"><span class="toc-number">1.3.0.2.0.3.</span> <span class="toc-text">2.3 接口中默认方法的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-静态方法"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">3. 静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-语法规则"><span class="toc-number">1.3.0.3.0.1.</span> <span class="toc-text">3.1 语法规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-静态方法的使用"><span class="toc-number">1.3.0.3.0.2.</span> <span class="toc-text">3.2 静态方法的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-两者的区别介绍"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">4. 两者的区别介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、函数式接口"><span class="toc-number">1.4.</span> <span class="toc-text">四、函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-函数式接口的由来"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1. 函数式接口的由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-函数式接口介绍"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2. 函数式接口介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-Supplier"><span class="toc-number">1.4.0.2.0.1.</span> <span class="toc-text">2.1 Supplier</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-Consumer"><span class="toc-number">1.4.0.2.0.2.</span> <span class="toc-text">2.2 Consumer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-Function"><span class="toc-number">1.4.0.2.0.3.</span> <span class="toc-text">2.3 Function</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-Predicate"><span class="toc-number">1.4.0.2.0.4.</span> <span class="toc-text">2.4 Predicate</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、方法引用"><span class="toc-number">1.5.</span> <span class="toc-text">五、方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-为什么要用方法引用"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1. 为什么要用方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-lambda表达式冗余"><span class="toc-number">1.5.0.1.0.1.</span> <span class="toc-text">1.1 lambda表达式冗余</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-解决方案"><span class="toc-number">1.5.0.1.0.2.</span> <span class="toc-text">1.2 解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-方法引用的格式"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2. 方法引用的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-对象名-方法名"><span class="toc-number">1.5.0.2.0.1.</span> <span class="toc-text">2.1 对象名::方法名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-类名-静态方法名"><span class="toc-number">1.5.0.2.0.2.</span> <span class="toc-text">2.2 类名::静态方法名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-类名-引用实例方法"><span class="toc-number">1.5.0.2.0.3.</span> <span class="toc-text">2.3 类名::引用实例方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-类名-构造器"><span class="toc-number">1.5.0.2.0.4.</span> <span class="toc-text">2.4 类名::构造器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-数组-构造器"><span class="toc-number">1.5.0.2.0.5.</span> <span class="toc-text">2.5 数组::构造器</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Stream-API"><span class="toc-number">1.6.</span> <span class="toc-text">六、Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-集合处理数据的弊端"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">1.集合处理数据的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Steam流式思想概述"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">2. Steam流式思想概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Stream流的获取方式"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">3. Stream流的获取方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-根据Collection获取"><span class="toc-number">1.6.0.3.0.1.</span> <span class="toc-text">3.1 根据Collection获取</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-通过Stream的of方法"><span class="toc-number">1.6.0.3.0.2.</span> <span class="toc-text">3.2 通过Stream的of方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Stream常用方法介绍"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">4.Stream常用方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-forEach"><span class="toc-number">1.6.0.4.0.1.</span> <span class="toc-text">4.1 forEach</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-count"><span class="toc-number">1.6.0.4.0.2.</span> <span class="toc-text">4.2 count</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-3-filter"><span class="toc-number">1.6.0.4.0.3.</span> <span class="toc-text">4.3 filter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-4-limit"><span class="toc-number">1.6.0.4.0.4.</span> <span class="toc-text">4.4 limit</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-5-skip"><span class="toc-number">1.6.0.4.0.5.</span> <span class="toc-text">4.5 skip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-6-map"><span class="toc-number">1.6.0.4.0.6.</span> <span class="toc-text">4.6 map</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-7-sorted"><span class="toc-number">1.6.0.4.0.7.</span> <span class="toc-text">4.7 sorted</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-8-distinct"><span class="toc-number">1.6.0.4.0.8.</span> <span class="toc-text">4.8 distinct</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-9-match"><span class="toc-number">1.6.0.4.0.9.</span> <span class="toc-text">4.9 match</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-10-find"><span class="toc-number">1.6.0.4.0.10.</span> <span class="toc-text">4.10 find</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-11-max和min"><span class="toc-number">1.6.0.4.0.11.</span> <span class="toc-text">4.11 max和min</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-12-reduce方法"><span class="toc-number">1.6.0.4.0.12.</span> <span class="toc-text">4.12 reduce方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-13-map和reduce的组合"><span class="toc-number">1.6.0.4.0.13.</span> <span class="toc-text">4.13 map和reduce的组合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-14-mapToInt"><span class="toc-number">1.6.0.4.0.14.</span> <span class="toc-text">4.14 mapToInt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-15-concat"><span class="toc-number">1.6.0.4.0.15.</span> <span class="toc-text">4.15 concat</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-16-综合案例"><span class="toc-number">1.6.0.4.0.16.</span> <span class="toc-text">4.16 综合案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Stream结果收集"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">5.Stream结果收集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-1-结果收集到集合中"><span class="toc-number">1.6.0.5.0.1.</span> <span class="toc-text">5.1 结果收集到集合中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-2-结果收集到数组中"><span class="toc-number">1.6.0.5.0.2.</span> <span class="toc-text">5.2 结果收集到数组中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3-对流中的数据做聚合计算"><span class="toc-number">1.6.0.5.0.3.</span> <span class="toc-text">5.3 对流中的数据做聚合计算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-4-对流中数据做分组操作"><span class="toc-number">1.6.0.5.0.4.</span> <span class="toc-text">5.4 对流中数据做分组操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-5-对流中的数据做分区操作"><span class="toc-number">1.6.0.5.0.5.</span> <span class="toc-text">5.5 对流中的数据做分区操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-6-对流中的数据做拼接"><span class="toc-number">1.6.0.5.0.6.</span> <span class="toc-text">5.6 对流中的数据做拼接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-并行的Stream流"><span class="toc-number">1.6.0.5.1.</span> <span class="toc-text">6. 并行的Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6-1-串行的Stream流"><span class="toc-number">1.6.0.5.1.1.</span> <span class="toc-text">6.1 串行的Stream流</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-2-并行流"><span class="toc-number">1.6.0.5.1.2.</span> <span class="toc-text">6.2 并行流</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-3-并行流和串行流对比"><span class="toc-number">1.6.0.5.1.3.</span> <span class="toc-text">6.3 并行流和串行流对比</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-4-线程安全问题"><span class="toc-number">1.6.0.5.1.4.</span> <span class="toc-text">6.4 线程安全问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Optional类"><span class="toc-number">1.7.</span> <span class="toc-text">七、Optional类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-以前对null-的处理"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">1. 以前对null 的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Optional类"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">2. Optional类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Optional的基本使用"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">3. Optional的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Optional的常用方法"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">4. Optional的常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、新时间日期API"><span class="toc-number">1.8.</span> <span class="toc-text">八、新时间日期API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-旧版日期时间的问题"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">1.旧版日期时间的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-新日期时间API介绍"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">2. 新日期时间API介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-日期时间的常见操作"><span class="toc-number">1.8.0.2.0.1.</span> <span class="toc-text">2.1 日期时间的常见操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-日期时间的修改和比较"><span class="toc-number">1.8.0.2.0.2.</span> <span class="toc-text">2.2 日期时间的修改和比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-格式化和解析操作"><span class="toc-number">1.8.0.3.</span> <span class="toc-text">2.3 格式化和解析操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Instant类"><span class="toc-number">1.8.0.4.</span> <span class="toc-text">2.4 Instant类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-计算日期时间差"><span class="toc-number">1.8.0.5.</span> <span class="toc-text">2.5 计算日期时间差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-时间校正器"><span class="toc-number">1.8.0.6.</span> <span class="toc-text">2.6 时间校正器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-日期时间的时区"><span class="toc-number">1.8.0.7.</span> <span class="toc-text">2.7 日期时间的时区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、其他新特性"><span class="toc-number">1.9.</span> <span class="toc-text">九、其他新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-重复注解"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">1.重复注解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-定义一个重复注解的容器"><span class="toc-number">1.9.0.1.0.1.</span> <span class="toc-text">1.1 定义一个重复注解的容器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-定义一个可以重复的注解"><span class="toc-number">1.9.0.1.0.2.</span> <span class="toc-text">1.2 定义一个可以重复的注解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-3-配置多个重复的注解"><span class="toc-number">1.9.0.1.0.3.</span> <span class="toc-text">1.3 配置多个重复的注解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-4-解析得到指定的注解"><span class="toc-number">1.9.0.1.0.4.</span> <span class="toc-text">1.4 解析得到指定的注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-类型注解"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">2.类型注解</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg5.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Wang</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">JDK1.8新特性</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-01-16 11:28:24"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-01-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-03-09 18:03:53"><i class="fas fa-history fa-fw"></i> 更新于 2023-03-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="内容的介绍"><a href="#内容的介绍" class="headerlink" title="内容的介绍"></a>内容的介绍</h1><ol>
<li>了解Java发展史</li>
<li>Lambda表达式</li>
<li>接口的增强</li>
<li>函数式接口</li>
<li>方法引用</li>
<li>Stream API</li>
<li>Optional</li>
<li>新时间日期API</li>
<li>其他新特性</li>
</ol>
<h2 id="一、Java发展历史"><a href="#一、Java发展历史" class="headerlink" title="一、Java发展历史"></a>一、Java发展历史</h2><h4 id="1-Java的发展历史"><a href="#1-Java的发展历史" class="headerlink" title="1. Java的发展历史"></a>1. Java的发展历史</h4><p> Sun公司在1991年成立了一个称为绿色计划( Green Project )的项目，由James Gosling(高斯林)博<br>土领导，绿色计划<br>的目的是开发一种能够在各种消费性电子产品(机顶盒、冰箱、收音机等)上运行的程序架构。这个项目的<br>产品就是<br>    Java语言的前身: Oak(橡树)。Oak当时在消费品市场上并不算成功，但随着1995年互联网潮流的兴起，Oak迅速找到了最适合自己发展的市场定位。</p>
<ul>
<li>JDK Beta - 1995</li>
<li>JDK 1.0 - 1996年1月 (真正第一个稳定的版本JDK 1.0.2，被称作 Java 1 )</li>
<li>JDK 1.1 - 1997年2月</li>
<li>J2SE 1.2 - 1998年12月</li>
<li>J2ME（Java 2 Micro Edition，Java 2平台的微型版），应用于移动、无线及有限资源的环境。</li>
<li>J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境。</li>
<li>J2EE（Java 2 Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。</li>
<li>J2SE 1.3 - 2000年5月</li>
<li>J2SE 1.4 - 2002年2月</li>
<li>J2SE 5.0 - 2004年9月</li>
<li>Java SE 6 - 2006年12月</li>
<li>Java SE 7 - 2011年7月</li>
<li><strong>Java SE 8</strong>（LTS） - 2014年3月</li>
<li>Java SE 9 - 2017年9月</li>
<li>Java SE 10（18.3） - 2018年3月</li>
<li><strong>Java SE 11</strong>（18.9 LTS） - 2018年9月</li>
<li>Java SE 12（19.3） - 2019年3月</li>
<li>Java SE 13（19.9) - 2019年9月</li>
<li>Java SE 14（20.3) - 2020年3月</li>
<li>Java SE 15（20.9) - 2020年9月<br>  我们可以看到Java SE的主要版本大约每两年发布一次，直到Java SE 6到Java SE 7开始花了五年时间，之后又花了三年时间到达Java SE 8。</li>
</ul>
<h4 id="2-OpenJDK和OracleJDK"><a href="#2-OpenJDK和OracleJDK" class="headerlink" title="2.OpenJDK和OracleJDK"></a>2.OpenJDK和OracleJDK</h4><h6 id="2-1-Open-JDK来源"><a href="#2-1-Open-JDK来源" class="headerlink" title="2.1 Open JDK来源"></a>2.1 Open JDK来源</h6><pre><code>Java 由 Sun 公司发明，Open JDK是Sun在2006年末把Java开源而形成的项目。也就是说Open JDK</code></pre><p>是Java SE平台版的开源和免费实现，它由 SUN 和 Java 社区提供支持，2009年 Oracle 收购了 Sun 公司，自此 Java 的维护方之一的<br>SUN 也变成了 Oracle。</p>
<h6 id="2-2-Open-JDK-和-Oracle-JDK的关系"><a href="#2-2-Open-JDK-和-Oracle-JDK的关系" class="headerlink" title="2.2 Open JDK 和 Oracle JDK的关系"></a>2.2 Open JDK 和 Oracle JDK的关系</h6><pre><code>大多数 JDK 都是在 Open JDK 的基础上进一步编写实现的，比如 IBM J9, Oracle JDK 和 Azul Zulu,</code></pre><p>Azul Zing。<br>    Oracle JDK完全由 Oracle 公司开发，Oracle JDK是基于Open JDK源代码的商业版本。此外，它包含闭源组件。<br>    Oracle JDK根据二进制代码许可协议获得许可，在没有商业许可的情况下，在2019年1月之后发布的<br>Oracle Java SE 8的公开更新将无法用于商业或生产用途。但是 Open JDK是完全开源的，可以自由使用。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/b43b08bf2f8d45839d1820b5d6097633.png" alt="在这里插入图片描述"></p>
<h6 id="2-3-Open-JDK-官网介绍"><a href="#2-3-Open-JDK-官网介绍" class="headerlink" title="2.3 Open JDK 官网介绍"></a>2.3 Open JDK 官网介绍</h6><p>Open JDK 官网： <a href="http://openjdk.java.net/" target="_blank" rel="noopener">http://openjdk.java.net/</a> 。 JDK Enhancement Proposals(JDK增强建议)。通俗的讲JEP就是JDK的新特性<br><strong>小结：</strong><br>Oracle JDK是基于Open JDK源代码的商业版本。我们要学习Java新技术可以去Open JDK 官网学习。</p>
<h2 id="二、Lambda表达式"><a href="#二、Lambda表达式" class="headerlink" title="二、Lambda表达式"></a>二、Lambda表达式</h2><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h4><ul>
<li>创建一个新的线程，指定线程要执行的任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启一个新的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">            System.out.println(<span class="string">"新线程中执行的代码 : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"主线程中的代码："</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码分析：</p>
<ol>
<li>Thread类需要一个Runnable接口作为参数，其中的抽象方法run方法是用来指定线程任务内容的核心</li>
<li>为了指定run方法体，不得不需要Runnable的实现类</li>
<li>为了省去定义一个Runnable 的实现类，不得不使用匿名内部类</li>
<li>必须覆盖重写抽象的run方法，所有的方法名称，方法参数，方法返回值不得不都重写一遍，而且不能出错</li>
<li>而实际上，我们只在乎方法体中的代码</li>
</ol>
<h4 id="2-Lambda表达式初体验"><a href="#2-Lambda表达式初体验" class="headerlink" title="2.Lambda表达式初体验"></a>2.Lambda表达式初体验</h4><ul>
<li>Lambda表达式是一个匿名函数，可以理解为一段可以传递的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"新线程中Lambada : "</span> + Thread.currentThread().getName());</span><br><span class="line"> &#125;).start();</span><br></pre></td></tr></table></figure>
<ul>
<li>Lambda表达式的优点：简化了匿名内部类的使用，语法更加简单。</li>
<li>匿名内部类语法冗余，体验了Lambda表达式后，发现Lambda表达式是简化匿名内部类的一种方式。</li>
</ul>
<h4 id="3-Lambda的语法规则"><a href="#3-Lambda的语法规则" class="headerlink" title="3. Lambda的语法规则"></a>3. Lambda的语法规则</h4><ul>
<li>Lambda省去了面向对象的条条框框，Lambda的标准格式由3个部分组成：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; </span><br><span class="line">	代码体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>格式说明：</strong></p>
<ul>
<li>(参数类型 参数名称):参数列表</li>
<li>{代码体;} :方法体</li>
<li>-&gt; : 箭头，分割参数列表和方法体<h6 id="3-1-Lambda练习1"><a href="#3-1-Lambda练习1" class="headerlink" title="3.1 Lambda练习1"></a>3.1 Lambda练习1</h6></li>
</ul>
<ol>
<li>练习无参无返回值的Lambda<br>定义一个接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后创建主方法使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Lambada2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        goShow(<span class="keyword">new</span> UserService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"show 方法执行了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line"></span><br><span class="line">        goShow(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Lambada show 方法执行了"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goShow</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        userService.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/e34bd1df40be4cb49421b2685349ccc6.png" alt="在这里插入图片描述"></p>
<h6 id="3-2-Lambda练习2"><a href="#3-2-Lambda练习2" class="headerlink" title="3.2 Lambda练习2"></a>3.2 Lambda练习2</h6><ul>
<li>完成一个有参且有返回值得Lambda表达式案例</li>
</ul>
<ol>
<li>创建一个Person对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在List集合中保存多个Person对象，然后对这些对象做根据age排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Lambada</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"周杰伦"</span>, <span class="number">33</span>, <span class="number">175</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"刘德华"</span>, <span class="number">43</span>, <span class="number">185</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"刘德华2"</span>, <span class="number">43</span>, <span class="number">1285</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"周星驰"</span>, <span class="number">43</span>, <span class="number">177</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"郭富城"</span>, <span class="number">23</span>, <span class="number">170</span>));</span><br><span class="line">        </span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> a == <span class="number">0</span> ? o1.getHeight() - o2.getHeight():o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在sort方法的第二个参数是一个Comparator接口的匿名内部类，且执行的方法有参数和返回<br>值，那么我们可以改写为Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Lambada</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"周杰伦"</span>, <span class="number">33</span>, <span class="number">175</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"刘德华"</span>, <span class="number">43</span>, <span class="number">185</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"刘德华2"</span>, <span class="number">43</span>, <span class="number">1285</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"周星驰"</span>, <span class="number">43</span>, <span class="number">177</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"郭富城"</span>, <span class="number">23</span>, <span class="number">170</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(list,(Person o1, Person o2 ) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-2-FunctionalInterface注解"><a href="#3-2-FunctionalInterface注解" class="headerlink" title="3.2 @FunctionalInterface注解"></a>3.2 @FunctionalInterface注解</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个标志注解，被该注解修饰的接口只能声明一个抽象方法</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="3-3-Lambda表达式的原理"><a href="#3-3-Lambda表达式的原理" class="headerlink" title="3.3 Lambda表达式的原理"></a>3.3 Lambda表达式的原理</h6><ul>
<li>匿名内部类的本质是在编译时生成一个Class 文件。XXXXX$1.class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Lambada</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启一个新的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"新线程中执行的代码 : "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程中的代码："</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    System.out.println("-----------");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("新线程中Lambada : " + Thread.currentThread().getName());</span></span><br><span class="line"><span class="comment">        &#125;).start();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/c6f5acf96cdb4d1e98224f25a210cfcb.png" alt="在这里插入图片描述"></li>
</ul>
<p>还可以通过反编译工具来查看生成的代码 XJad 工具来查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Lambda</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">new</span> StringBuilder()).append(<span class="string">"新线程中执行的代码 : "</span>).append(Thread.currentThread().getName()).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Demo01Lambda$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么Lambda表达式的原理是什么呢？我们也通过反编译工具来查看</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/79a45b0e2934424896f99ee24c5618ac.png" alt="在这里插入图片描述"></p>
<p>写的有Lambda表达式的class文件，我们通过XJad查看报错。这时我们可以通过JDK自带的一个工具：<br>javap 对字节码进行反汇编操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javap -c -p 文件名<span class="class">.<span class="keyword">class</span> </span></span><br><span class="line">-c:表示对代码进行反汇编 </span><br><span class="line">-p:显示所有的类和成员</span><br></pre></td></tr></table></figure>
<p>反汇编的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">jose</span>.<span class="title">jdk</span>.<span class="title">lambada</span>.<span class="title">Demo02Lambada</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.jose.jdk.lambada.Demo02Lambada();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class com/jose/jdk/lambada/Demo02Lambada$1</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #3                  // Method com/jose/jdk/lambada/Demo02Lambada$1."&lt;init&gt;":()V</span><br><span class="line">       7: invokestatic  #4                  // Method goShow:(Lcom/jose/jdk/lambada/service/UserService;)V</span><br><span class="line">      10: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: ldc           #6                  // String ----------------------</span><br><span class="line">      15: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      18: invokedynamic #8,  0              // InvokeDynamic #0:show:()Lcom/jose/jdk/lambada/service/UserService;</span><br><span class="line">      23: invokestatic  #4                  // Method goShow:(Lcom/jose/jdk/lambada/service/UserService;)V</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goShow</span><span class="params">(com.jose.jdk.lambada.service.UserService)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokeinterface #9,  1            // InterfaceMethod com/jose/jdk/lambada/service/UserService.show:()V</span><br><span class="line">       <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #10                 // String Lambada show 方法执行了</span><br><span class="line">       5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个反编译的源码中我们看到了一个静态方法 lambda$main$0()，这个方法里面做了什么事情呢？我<br>们通过debug的方式来查看下：</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/c01eb1e4c3a8445787ae3dd18e9911ea.png" alt="在这里插入图片描述"><br>上面的效果可以理解为如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">       goShow(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"Lambada show 方法执行了"</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> goShow(UserService userService) &#123;</span><br><span class="line"></span><br><span class="line">       userService.show();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>为了更加直观的理解这个内容，我们可以在运行的时候添加 -<br>Djdk.internal.lambda.dumpProxyClasses, 加上这个参数会将内部class码输出到一个文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djdk.internal.lambda.dumpProxyClasses 要运行的包名.类名</span><br></pre></td></tr></table></figure>
<p>命令执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jose@192 classes % java -Djdk.internal.lambda.dumpProxyClasses com.jose.jdk.lambada.Demo02Lambada</span><br><span class="line">show 方法执行了</span><br><span class="line">----------------------</span><br><span class="line">Lambada show 方法执行了</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/208bdfadbe7c47b1a46c95f13019ac1f.png" alt="在这里插入图片描述"><br>反编译后的内容：<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/83513200c89b4b2fb1ab23f56fb51c5f.png" alt="在这里插入图片描述"></p>
<p>可以看到这个匿名的内部类实现了UserService接口，并重写了show()方法。在show方法中调用了<br>Demo03Lambda.lambda$main$0(),也就是调用了Lambda中的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       goShow(<span class="keyword">new</span> UserService() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Demo02Lambda.lambda$main$<span class="number">0</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goShow</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">       userService.show();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong><br>匿名内部类在编译的时候会产生一个class文件。<br>Lambda表达式在程序运行的时候会形成一个类。</p>
<ol>
<li>在类中新增了一个方法，这个方法的方法体就是Lambda表达式中的代码</li>
<li>还会形成一个匿名内部类，实现接口，重写抽象方法</li>
<li>在接口中重写方法会调用新生成的方法</li>
</ol>
<h4 id="4-Lambda表达式的省略写法"><a href="#4-Lambda表达式的省略写法" class="headerlink" title="4.Lambda表达式的省略写法"></a>4.Lambda表达式的省略写法</h4><p>在lambda表达式的标准写法基础上，可以使用省略写法的规则为：</p>
<ol>
<li>小括号内的参数类型可以省略</li>
<li>如果小括号内有且仅有一个参数，则小括号可以省略</li>
<li>如果大括号内有且仅有一个语句，可以同时省略大括号，return 关键字及语句分号。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Lambada</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        goStudent((String name, Integer age) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> name + age + <span class="string">"666..."</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   省略写法</span></span><br><span class="line">        goStudent((name, age) -&gt; name + age + <span class="string">"666..."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">        goOrder((String name) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6666</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   省略写法</span></span><br><span class="line">        goOrder(name -&gt; <span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goStudent</span><span class="params">(StudentService studentService)</span> </span>&#123;</span><br><span class="line">        studentService.show(<span class="string">"张三"</span>, <span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goOrder</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line">        orderService.show(<span class="string">"李四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-Lambda表达式的使用前提"><a href="#5-Lambda表达式的使用前提" class="headerlink" title="5.Lambda表达式的使用前提"></a>5.Lambda表达式的使用前提</h4><p>Lambda表达式的语法是非常简洁的，但是Lambda表达式不是随便使用的，使用时有几个条件要特别注<br>意 </p>
<ol>
<li><p>方法的参数或局部变量类型必须为接口才能使用Lambda</p>
</li>
<li><p>接口中有且仅有一个抽象方法(<code>@FunctionalInterface</code>)</p>
<h6 id="6-Lambda和匿名内部类的对比"><a href="#6-Lambda和匿名内部类的对比" class="headerlink" title="6.Lambda和匿名内部类的对比"></a>6.Lambda和匿名内部类的对比</h6><p>Lambda和匿名内部类的对比</p>
</li>
<li><p>所需类型不一样</p>
<blockquote>
<p>匿名内部类的类型可以是 类，抽象类，接口Lambda表达式需要的类型必须是接口</p>
</blockquote>
</li>
<li><p>抽象方法的数量不一样</p>
<blockquote>
<p>匿名内部类所需的接口中的抽象方法的数量是随意的Lambda表达式所需的接口中只能有一个抽象方法</p>
</blockquote>
</li>
<li><p>实现原理不一样</p>
<blockquote>
<p> 匿名内部类是在编译后形成一个classLambda表达式是在程序运行的时候动态生成class</p>
</blockquote>
</li>
</ol>
<h2 id="三、接口中新增的方法"><a href="#三、接口中新增的方法" class="headerlink" title="三、接口中新增的方法"></a>三、接口中新增的方法</h2><h4 id="1-JDK8中接口的新增"><a href="#1-JDK8中接口的新增" class="headerlink" title="1. JDK8中接口的新增"></a>1. JDK8中接口的新增</h4><p>在JDK8中针对接口有做增强，在JDK8之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">	 静态常量; </span><br><span class="line">	 抽象方法;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>JDK8之后对接口做了增加，接口中可以有<strong>默认方法和静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123; </span><br><span class="line">静态常量; </span><br><span class="line">	抽象方法; </span><br><span class="line">	默认方法;</span><br><span class="line">	静态方法; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-默认方法"><a href="#2-默认方法" class="headerlink" title="2.默认方法"></a>2.默认方法</h4><h6 id="2-1-为什么要增加默认方法"><a href="#2-1-为什么要增加默认方法" class="headerlink" title="2.1 为什么要增加默认方法"></a>2.1 为什么要增加默认方法</h6><p>在JDK8以前接口中只能有抽象方法和静态常量，会存在以下的问题：<br>如果接口中新增抽象方法，那么实现类都必须要抽象这个抽象方法，非常不利于接口的扩展的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        A c = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中新增抽象方法，所有实现类都需要重写这个方法，不利于接口的扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-2-接口默认方法的格式"><a href="#2-2-接口默认方法的格式" class="headerlink" title="2.2 接口默认方法的格式"></a>2.2 接口默认方法的格式</h6><p> 接口中默认方法的语法格式是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123; </span><br><span class="line">	修饰符 <span class="keyword">default</span> 返回值类型 方法名&#123; </span><br><span class="line">		方法体;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.test3();</span><br><span class="line">        A c = <span class="keyword">new</span> C();</span><br><span class="line">        c.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中新增抽象方法，所有实现类都需要重写这个方法，不利于接口的扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中定义的默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> String <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口中的默认方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现类中重写了默认方法..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-接口中默认方法的使用"><a href="#2-3-接口中默认方法的使用" class="headerlink" title="2.3 接口中默认方法的使用"></a>2.3 接口中默认方法的使用</h6><p>接口中的默认方法有两种使用方式</p>
<ol>
<li>实现类直接调用接口的默认方法</li>
<li>实现类重写接口的默认方法</li>
</ol>
<h4 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h4><p> JDK8中为接口新增了静态方法，作用也是为了接口的扩展</p>
<h6 id="3-1-语法规则"><a href="#3-1-语法规则" class="headerlink" title="3.1 语法规则"></a>3.1 语法规则</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123; </span><br><span class="line">	修饰符 <span class="keyword">static</span> 返回值类型 方法名&#123;</span><br><span class="line"> 		方法体; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.test3();</span><br><span class="line">        A c = <span class="keyword">new</span> C();</span><br><span class="line">        c.test3();</span><br><span class="line">        A.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中新增抽象方法，所有实现类都需要重写这个方法，不利于接口的扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中定义的默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> String <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口中的默认方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现类中重写了默认方法..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-2-静态方法的使用"><a href="#3-2-静态方法的使用" class="headerlink" title="3.2 静态方法的使用"></a>3.2 静态方法的使用</h6><p>接口中的静态方法在实现类中是不能被重写的，调用的话只能通过接口类型来实现: 接口名.静态方法名<br>();</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/4d0fcd3f31194046ad665628089a39c2.png" alt="在这里插入图片描述"></p>
<h4 id="4-两者的区别介绍"><a href="#4-两者的区别介绍" class="headerlink" title="4. 两者的区别介绍"></a>4. 两者的区别介绍</h4><ol>
<li>默认方法通过实例调用，静态方法通过接口名调用</li>
<li>默认方法可以被继承，实现类可以直接调用接口默认方法，也可以重写接口默认方法</li>
<li>静态方法不能被继承，实现类不能重写接口的静态方法，只能使用接口名调用</li>
</ol>
<h2 id="四、函数式接口"><a href="#四、函数式接口" class="headerlink" title="四、函数式接口"></a>四、函数式接口</h2><h4 id="1-函数式接口的由来"><a href="#1-函数式接口的由来" class="headerlink" title="1. 函数式接口的由来"></a>1. 函数式接口的由来</h4><p> 我们知道使用Lambda表达式的前提是需要有函数式接口，而Lambda表达式使用时不关心接口名，<br>抽象方法名。只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda表达式更加的方<br>法，在JDK中提供了大量常用的函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Fun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fun1((arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Operator operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = operator.getSum(arr);</span><br><span class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-函数式接口介绍"><a href="#2-函数式接口介绍" class="headerlink" title="2. 函数式接口介绍"></a>2. 函数式接口介绍</h4><p>在JDK中帮我们提供的有函数式接口，主要是在 java.util.function 包中。</p>
<h6 id="2-1-Supplier"><a href="#2-1-Supplier" class="headerlink" title="2.1 Supplier"></a>2.1 Supplier</h6><p> 无参有返回值的接口，对于的Lambda表达式需要提供一个返回数据的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fun1(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> arr[] = &#123;<span class="number">22</span>, <span class="number">33</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">44</span>, <span class="number">99</span>, <span class="number">10</span>&#125;;</span><br><span class="line">            <span class="comment">// 计算出数组中的最大值</span></span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get() 是一个无参的有返回值的 抽象方法</span></span><br><span class="line">        Integer max = supplier.get();</span><br><span class="line">        System.out.println(<span class="string">"max = "</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="2-2-Consumer"><a href="#2-2-Consumer" class="headerlink" title="2.2 Consumer"></a>2.2 Consumer</h6><p> 有参无返回值得接口,前面介绍的Supplier接口是用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：将输入的数据统一转换为小写输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">            System.out.println(msg + <span class="string">"-&gt; 转换为小写："</span> + msg.toLowerCase());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认方法:andThen</strong><br> 如果一个方法的参数和返回值全部是Consumer类型，那么就可以实现效果，消费一个数据的时候，<br>首先做一个操作，然后再做一个操作，实现组合，而这个方法就是Consumer接口中的default方法<br>andThen方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123;</span><br><span class="line">        accept(t);</span><br><span class="line">        after.accept(t);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAndThenTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test2(msg1 -&gt; &#123;</span><br><span class="line">            System.out.println(msg1 + <span class="string">"-&gt; 转换为小写："</span> + msg1.toLowerCase());</span><br><span class="line">        &#125;, msg2 -&gt; &#123;</span><br><span class="line">            System.out.println(msg2 + <span class="string">"-&gt; 转换为大写："</span> + msg2.toUpperCase());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="comment">//        c1.accept(str); // 转小写</span></span><br><span class="line"><span class="comment">//         c2.accept(str); // 转大写</span></span><br><span class="line">         c1.andThen(c2).accept(str);</span><br><span class="line">         c2.andThen(c1).accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-3-Function"><a href="#2-3-Function" class="headerlink" title="2.3 Function"></a>2.3 Function</h6><p> 有参有返回值的接口，Function接口是根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有参数有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：传递进入一个字符串返回一个数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(msg);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        Integer apply = function.apply(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"apply = "</span> + apply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认方法：andThen，也是用来进行组合操作，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionAndThenTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(msg);</span><br><span class="line">        &#125;, msg2 -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> msg2 * <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)</span> </span>&#123; <span class="comment">/*Integer i1 = f1.apply("666"); Integer i2 = f2.apply(i1);*/</span></span><br><span class="line">        Integer i2 = f1.andThen(f2).apply(<span class="string">"666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i2:"</span> + i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的compose方法的作用顺序和andThen方法刚好相反<br>而静态方法identity则是，输入什么参数就返回什么参数</p>
<h6 id="2-4-Predicate"><a href="#2-4-Predicate" class="headerlink" title="2.4 Predicate"></a>2.4 Predicate</h6><p>有参且返回值为Boolean的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> msg.length() &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;, <span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Predicate&lt;String&gt; predicate, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = predicate.test(msg);</span><br><span class="line">        System.out.println(<span class="string">"b:"</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Predicate中的默认方法提供了逻辑关系操作 and or negate isEquals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDefaultTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> msg1.contains(<span class="string">"H"</span>);</span><br><span class="line">        &#125;, msg2 -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> msg2.contains(<span class="string">"W"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// b1 包含H b2 包含W</span></span><br><span class="line">        <span class="comment">// p1 包含H 同时 p2 包含W</span></span><br><span class="line">        <span class="keyword">boolean</span> bb1 = p1.and(p2).test(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// p1 包含H 或者 p2 包含W</span></span><br><span class="line">        <span class="keyword">boolean</span> bb2 = p1.or(p2).test(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// p1 不包含H</span></span><br><span class="line">        <span class="keyword">boolean</span> bb3 = p1.negate().test(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(bb1); <span class="comment">// FALSE</span></span><br><span class="line">        System.out.println(bb2); <span class="comment">// TRUE</span></span><br><span class="line">        System.out.println(bb3); <span class="comment">// FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、方法引用"><a href="#五、方法引用" class="headerlink" title="五、方法引用"></a>五、方法引用</h2><h4 id="1-为什么要用方法引用"><a href="#1-为什么要用方法引用" class="headerlink" title="1. 为什么要用方法引用"></a>1. 为什么要用方法引用</h4><h6 id="1-1-lambda表达式冗余"><a href="#1-1-lambda表达式冗余" class="headerlink" title="1.1 lambda表达式冗余"></a>1.1 lambda表达式冗余</h6><p>在使用Lambda表达式的时候，也会出现代码冗余的情况，比如：用Lambda表达式求一个数组的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionRefTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printMax(a -&gt; &#123;</span><br><span class="line">            <span class="comment">// Lambda表达式中的代码和 getTotal中的代码冗余了</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"数组之和："</span> + sum);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组中的所有元素的和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotal</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组之和："</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(Consumer&lt;<span class="keyword">int</span>[]&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">        consumer.accept(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h6><p> 因为在Lambda表达式中要执行的代码和我们另一个方法中的代码是一样的，这时就没有必要重写一<br>份逻辑了，这时我们就可以“引用”重复代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionRefTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// :: 方法引用 也是JDK8中的新的语法</span></span><br><span class="line">        printMax(FunctionRefTest02::getTotal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求数组中的所有元素的和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTotal</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组之和："</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(Consumer&lt;<span class="keyword">int</span>[]&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">        consumer.accept(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>::</strong> 方法引用 也是JDK8中的新的语法</p>
<h4 id="2-方法引用的格式"><a href="#2-方法引用的格式" class="headerlink" title="2. 方法引用的格式"></a>2. 方法引用的格式</h4><p>符号表示： <strong>::</strong><br>符号说明：双冒号为方法引用运算符，而它所在的表达式被称为 方法引用<br>应用场景：如果Lambda表达式所要实现的方案，已经有其他方法存在相同的方案，那么则可以使用方<br>法引用。<br>常见的引用方式：<br>方法引用在JDK8中使用是相当灵活的，有以下几种形式：</p>
<ol>
<li>instanceName::methodName 对象::方法名</li>
<li>ClassName::staticMethodName 类名::静态方法</li>
<li>ClassName::methodName 类名::普通方法</li>
<li>ClassName::new 类名::new 调用的构造器</li>
<li>TypeName[]::new String[]::new 调用数组的构造器<h6 id="2-1-对象名-方法名"><a href="#2-1-对象名-方法名" class="headerlink" title="2.1 对象名::方法名"></a>2.1 对象名::方法名</h6>这是最常见的一种用法。如果一个类中的已经存在了一个成员方法，则可以通过对象名引用成员方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date now = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Supplier-无参有返回值的接口</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier1 = <span class="keyword">new</span> Supplier&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> now.getTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Supplier&lt;Long&gt; supplier2 = () -&gt; now.getTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">    System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后我们通过 方法引用 的方式来处理</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier3 = now::getTime;</span><br><span class="line">    System.out.println(supplier3.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法引用的注意事项：</p>
<ol>
<li>被引用的方法，参数要和接口中的抽象方法的参数一样</li>
<li>当接口抽象方法有返回值时，被引用的方法也必须有返回值<h6 id="2-2-类名-静态方法名"><a href="#2-2-类名-静态方法名" class="headerlink" title="2.2 类名::静态方法名"></a>2.2 类名::静态方法名</h6>也是比较常用的方式：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Long&gt; supplier1 = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">    <span class="comment">// 通过 方法引用 来实现</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier2 = System::currentTimeMillis;</span><br><span class="line">    System.out.println(supplier2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-类名-引用实例方法"><a href="#2-3-类名-引用实例方法" class="headerlink" title="2.3 类名::引用实例方法"></a>2.3 类名::引用实例方法</h6><p> Java面向对象中，类名只能调用静态方法，类名引用实例方法是用前提的，实际上是拿第一个参数作<br>为方法的调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Function 有参有返回值</span></span><br><span class="line">    Function&lt;String, Integer&gt; function = (s) -&gt; s.length();</span><br><span class="line">    System.out.println(function.apply(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法引用来实现</span></span><br><span class="line">    Function&lt;String, Integer&gt; function1 = String::length;</span><br><span class="line">    System.out.println(function1.apply(<span class="string">"hahahaha"</span>));</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;String, Integer, String&gt; function2 = String::substring;</span><br><span class="line">    String msg = function2.apply(<span class="string">"HelloWorld"</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-4-类名-构造器"><a href="#2-4-类名-构造器" class="headerlink" title="2.4 类名::构造器"></a>2.4 类名::构造器</h6><p> 由于构造器的名称和类名完全一致，所以构造器引用使用 ::new 的格式使用，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Person&gt; sup = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    <span class="comment">// 然后通过 方法引用来实现</span></span><br><span class="line">    Supplier&lt;Person&gt; sup1 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line">    BiFunction&lt;String, Integer, Person&gt; function = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(function.apply(<span class="string">"张三"</span>, <span class="number">22</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-5-数组-构造器"><a href="#2-5-数组-构造器" class="headerlink" title="2.5 数组::构造器"></a>2.5 数组::构造器</h6><p> 数组是怎么构造出来的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun1 = (len) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[len];</span><br><span class="line">    &#125;;</span><br><span class="line">    String[] a1 = fun1.apply(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组的长度是："</span> + a1.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法引用 的方式来调用数组的构造器</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] a2 = fun2.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组的长度是："</span> + a2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：方法引用是对Lambda表达式符合特定情况下的一种缩写方式，它使得我们的Lambda表达式更加<br>的精简，也可以理解为lambda表达式的缩写形式，不过要注意的是方法引用只能引用已经存在的方法。</p>
<h2 id="六、Stream-API"><a href="#六、Stream-API" class="headerlink" title="六、Stream API"></a>六、Stream API</h2><h4 id="1-集合处理数据的弊端"><a href="#1-集合处理数据的弊端" class="headerlink" title="1.集合处理数据的弊端"></a>1.集合处理数据的弊端</h4><p> 当我们在需要对集合中的元素进行操作的时候，除了必需的添加，删除，获取外，最典型的操作就是<br>集合遍历，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个List集合</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"张三"</span>, <span class="string">"张三丰"</span>, <span class="string">"成龙"</span>, <span class="string">"周星驰"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取所有 姓张的信息</span></span><br><span class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">            list1.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取名称长度为3的用户</span></span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">            list2.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 输出所有的用户信息</span></span><br><span class="line">    <span class="keyword">for</span> (String s : list2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码针对与我们不同的需求总是一次次的循环循环循环.这时我们希望有更加高效的处理方式，这<br>时我们就可以通过JDK8中提供的Stream API来解决这个问题了。</p>
<p><strong>Stream更加优雅的解决方案：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 定义一个List集合</span></span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">"张三"</span>, <span class="string">"张三丰"</span>, <span class="string">"成龙"</span>, <span class="string">"周星驰"</span>);</span><br><span class="line">       <span class="comment">// 1.获取所有 姓张的信息</span></span><br><span class="line">       <span class="comment">// 2.获取名称长度为3的用户</span></span><br><span class="line">       <span class="comment">// 3. 输出所有的用户信息</span></span><br><span class="line">       list.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(s -&gt; &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;);</span><br><span class="line">       System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">       list.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(s -&gt; System.out.println(s));</span><br><span class="line">       list.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Steam流式思想概述"><a href="#2-Steam流式思想概述" class="headerlink" title="2. Steam流式思想概述"></a>2. Steam流式思想概述</h4><p>注意：Stream和IO流(InputStream/OutputStream)没有任何关系，请暂时忘记对传统IO流的固有印象！<br>Stream流式思想类似于工厂车间的“生产流水线”，Stream流不是一种数据结构，不保存数据，而是对数<br>据进行加工处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商<br>品。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/150f12c664944f94b728a5560381c2ce.png" alt="在这里插入图片描述"></p>
<h4 id="3-Stream流的获取方式"><a href="#3-Stream流的获取方式" class="headerlink" title="3. Stream流的获取方式"></a>3. Stream流的获取方式</h4><h6 id="3-1-根据Collection获取"><a href="#3-1-根据Collection获取" class="headerlink" title="3.1 根据Collection获取"></a>3.1 根据Collection获取</h6><p> 首先，java.util.Collection 接口中加入了default方法 stream，也就是说Collection接口下的所有的实<br>现都可以通过steam方法来获取Stream流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 定义一个List集合</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.stream();</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.stream();</span><br><span class="line">    Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">    vector.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是Map接口别没有实现Collection接口，那这时怎么办呢？这时我们可以根据Map获取对应的key<br>value的集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Stream&lt;<span class="built_in">String</span>&gt; stream = map.keySet().stream(); <span class="comment">// key</span></span><br><span class="line">    Stream&lt;<span class="built_in">Object</span>&gt; stream1 = map.values().stream(); <span class="comment">// value</span></span><br><span class="line">    Stream&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;&gt; stream2 = map.entrySet().stream(); <span class="comment">// entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-通过Stream的of方法"><a href="#3-2-通过Stream的of方法" class="headerlink" title="3.2 通过Stream的of方法"></a>3.2 通过Stream的of方法</h6><p>在实际开发中我们不可避免的还是会操作到数组中的数据，由于数组对象不可能添加默认方法，所<br>以Stream接口中提供了静态方法of</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Stream&lt;<span class="built_in">String</span>&gt; a1 = Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>);</span><br><span class="line">    <span class="built_in">String</span>[] arr1 = &#123;<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>&#125;;</span><br><span class="line">    Stream&lt;<span class="built_in">String</span>&gt; arr11 = Stream.of(arr1);</span><br><span class="line">    Integer[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Stream&lt;Integer&gt; arr21 = Stream.of(arr2);</span><br><span class="line">    arr21.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 注意：基本数据类型的数组是不行的</span></span><br><span class="line">    int[] arr3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Stream.of(arr3).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Stream常用方法介绍"><a href="#4-Stream常用方法介绍" class="headerlink" title="4.Stream常用方法介绍"></a>4.Stream常用方法介绍</h4><p>Stream常用方法<br>Stream流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：<br>| <strong>方法名</strong> | <strong>方法作用</strong> | <strong>返回值类型</strong> | <strong>方法种类</strong> |<br>| ———- | ———— | ————– | ———— |<br>| count      | 统计个数     | long           | 终结         |<br>| forEach    | 逐一处理     | void           | 终结         |<br>| filter     | 过滤         | Stream         | 函数拼接     |<br>| limit      | 取用前几个   | Stream         | 函数拼接     |<br>| skip       | 跳过前几个   | Stream         | 函数拼接     |<br>| map        | 映射         | Stream         | 函数拼接     |<br>| concat     | 组合         | Stream         | 函数拼接     |</p>
<p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。本小节中，终结方法包括count 和forEach 方法。<br><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。（除了终结方法外，其余方法均为非终结方法。）<br><strong>Stream注意事项(重要)</strong> </p>
<ol>
<li>Stream只能操作一次</li>
<li>Stream方法返回的是新的流</li>
<li>Stream不调用终结方法，中间的操作不会执行</li>
</ol>
<h6 id="4-1-forEach"><a href="#4-1-forEach" class="headerlink" title="4.1 forEach"></a>4.1 forEach</h6><p> forEach用来遍历流中的数据的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> forEach(Consumer&lt;? <span class="keyword">super</span> T&gt; action);</span><br></pre></td></tr></table></figure>

<p>该方法接受一个Consumer接口，会将每一个流元素交给函数处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-2-count"><a href="#4-2-count" class="headerlink" title="4.2 count"></a>4.2 count</h6><p>Stream流中的count方法用来统计其中的元素个数的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure>
<p>该方法返回一个long值，代表元素的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    long count = Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-filter"><a href="#4-3-filter" class="headerlink" title="4.3 filter"></a>4.3 filter</h6><p>filter方法的作用是用来过滤数据的。返回符合条件的数据</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/7570b1dbf43c405b8a52a956edc9c721.png" alt="在这里插入图片描述"><br>可以通过filter方法将一个流转换成另一个子集流</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>该接口接收一个Predicate函数式接口参数作为筛选条件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>, <span class="string">"dd"</span>)</span><br><span class="line">            .filter((s) -&gt; s.contains(<span class="string">"a"</span>))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a2</span><br><span class="line">a3</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>

<h6 id="4-4-limit"><a href="#4-4-limit" class="headerlink" title="4.4 limit"></a>4.4 limit</h6><p>limit方法可以对流进行截取处理，支取前n个数据，<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/d2a7c0b7de1046899c32e82654b2fbf7.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br></pre></td></tr></table></figure>
<p>参数是一个long类型的数值，如果集合当前长度大于参数就进行截取，否则不操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>, <span class="string">"dd"</span>)</span><br><span class="line">            .limit(<span class="number">2</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a2</span><br></pre></td></tr></table></figure>

<h6 id="4-5-skip"><a href="#4-5-skip" class="headerlink" title="4.5 skip"></a>4.5 skip</h6><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/5f65d0109bec4fdc9644fcb720aa57c8.png" alt="在这里插入图片描述"><br>如果希望跳过前面几个元素，可以使用skip方法获取一个截取之后的新流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>, <span class="string">"dd"</span>)</span><br><span class="line">            .skip(<span class="number">2</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a3</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">aa</span><br><span class="line">dd</span><br></pre></td></tr></table></figure>

<h6 id="4-6-map"><a href="#4-6-map" class="headerlink" title="4.6 map"></a>4.6 map</h6><p>如果我们需要将流中的元素映射到另一个流中，可以使用map方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/11b5f1551c7342e982cfb4db2333c2bb.png" alt="在这里插入图片描述"><br>该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">     Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>)</span><br><span class="line">             <span class="comment">//.map(msg-&gt;Integer.parseInt(msg)) </span></span><br><span class="line">             .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line">             .forEach(System.out::println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-7-sorted"><a href="#4-7-sorted" class="headerlink" title="4.7 sorted"></a>4.7 sorted</h6><p>如果需要将数据排序，可以使用sorted方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; sorted();</span><br></pre></td></tr></table></figure>

<p>在使用的时候可以根据自然规则排序，也可以通过比较强来指定对应的排序规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"7"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"4"</span>)</span><br><span class="line">                <span class="comment">//.map(msg-&gt;Integer.parseInt(msg))</span></span><br><span class="line">                .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">//                .sorted()</span></span><br><span class="line">                .sorted((o1,o2) -&gt; o2 -o1)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-8-distinct"><a href="#4-8-distinct" class="headerlink" title="4.8 distinct"></a>4.8 distinct</h6><p>如果要去掉重复数据，可以使用distinct方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct();</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/f1f364f2d3fb45b6bf95ddc21bd007f9.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"7"</span>, <span class="string">"7"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"4"</span>)</span><br><span class="line">                <span class="comment">//.map(msg-&gt;Integer.parseInt(msg))</span></span><br><span class="line">                .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">//                .sorted()</span></span><br><span class="line">                .sorted((o1, o2) -&gt; o2 - o1)</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                        <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                        <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>))</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Person(name=张三, age=<span class="number">18</span>)</span><br><span class="line">Person(name=李四, age=<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>Stream流中的distinct方法对于基本数据类型是可以直接出重的，但是对于自定义类型，我们是需要重写hashCode和equals方法来移除重复元素。</p>
<h6 id="4-9-match"><a href="#4-9-match" class="headerlink" title="4.9 match"></a>4.9 match</h6><p>如果需要判断数据是否匹配指定的条件，可以使用match相关的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean anyMatch(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate); <span class="comment">// 元素是否有任意一个满足条件</span></span><br><span class="line"> boolean allMatch(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate); <span class="comment">// 元素是否都满足条件 </span></span><br><span class="line"> boolean noneMatch(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate); <span class="comment">// 元素是否都不满足条件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">    boolean b = Stream.of(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>, <span class="string">"7"</span>)</span><br><span class="line">            .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line">            <span class="comment">//.allMatch(s -&gt; s &gt; 0)</span></span><br><span class="line">            <span class="comment">// .anyMatch(s -&gt; s &gt;4)</span></span><br><span class="line">            .noneMatch(s -&gt; s &gt; <span class="number">9</span>);</span><br><span class="line">    System.out.println(b); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-10-find"><a href="#4-10-find" class="headerlink" title="4.10 find"></a>4.10 find</h6><p>如果我们需要找到某些数据，可以使用find方法来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst(); </span><br><span class="line">Optional&lt;T&gt; findAny();</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/f027e851043c4baab9547b1fd0507763.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;<span class="built_in">String</span>&gt; first = Stream.of(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>, <span class="string">"7"</span>).findFirst();</span><br><span class="line">System.out.println(first.get());</span><br><span class="line">Optional&lt;<span class="built_in">String</span>&gt; any = Stream.of(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>, <span class="string">"7"</span>).findAny();</span><br><span class="line">System.out.println(any.get());</span><br></pre></td></tr></table></figure>

<h6 id="4-11-max和min"><a href="#4-11-max和min" class="headerlink" title="4.11 max和min"></a>4.11 max和min</h6><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/1779b79927a448f6b4b67fa6733020d9.png" alt="在这里插入图片描述"><br>如果我们想要获取最大值和最小值，那么可以使用max和min方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; min(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator); </span><br><span class="line">Optional&lt;T&gt; max(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Optional&lt;Integer&gt; max = Stream.of(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>, <span class="string">"7"</span>)</span><br><span class="line">            .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line">            .max((o1, o2) -&gt; o1 - o2);</span><br><span class="line">    System.out.println(max.get());</span><br><span class="line">    Optional&lt;Integer&gt; min = Stream.of(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>, <span class="string">"7"</span>)</span><br><span class="line">            .map(Integer::<span class="built_in">parseInt</span>)</span><br><span class="line">            .min((o1, o2) -&gt; o1 - o2);</span><br><span class="line">    System.out.println(min.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-12-reduce方法"><a href="#4-12-reduce方法" class="headerlink" title="4.12 reduce方法"></a>4.12 reduce方法</h6><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/73f961586cc04f57af4db997d6aaa77f.png" alt="在这里插入图片描述"><br>如果需要将所有数据归纳得到一个数据，可以使用reduce方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    Integer sum = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">            <span class="comment">// identity默认值</span></span><br><span class="line">            <span class="comment">// 第一次的时候会将默认值赋值给x</span></span><br><span class="line">            <span class="comment">// 之后每次会将 上一次的操作结果赋值给x y就是每次从数据中获取的元素</span></span><br><span class="line">            .reduce(<span class="number">0</span>, (x, y) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"x="</span> + x + <span class="string">",y="</span> + y);</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    <span class="comment">// 获取 最大值</span></span><br><span class="line">    Integer max = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">            .reduce(<span class="number">0</span>, (x, y) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>,y=<span class="number">4</span></span><br><span class="line">x=<span class="number">4</span>,y=<span class="number">5</span></span><br><span class="line">x=<span class="number">9</span>,y=<span class="number">3</span></span><br><span class="line">x=<span class="number">12</span>,y=<span class="number">9</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h6 id="4-13-map和reduce的组合"><a href="#4-13-map和reduce的组合" class="headerlink" title="4.13 map和reduce的组合"></a>4.13 map和reduce的组合</h6><p>在实际开发中我们经常会将map和reduce一块来使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 1.求出所有年龄的总和</span></span><br><span class="line">    Integer sumAge = Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>))</span><br><span class="line">            <span class="comment">// 实现数据类型的转换</span></span><br><span class="line">            .map(Person::getAge)</span><br><span class="line">            .reduce(<span class="number">0</span>, <span class="attr">Integer</span>::sum);</span><br><span class="line">    System.out.println(sumAge);</span><br><span class="line">    <span class="comment">// 2.求出所有年龄中的最大值</span></span><br><span class="line">    Integer maxAge = Stream.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>))</span><br><span class="line">            <span class="comment">// 实现数据类型的转换，符合reduce对数据的要</span></span><br><span class="line">            .map(Person::getAge)</span><br><span class="line">            .reduce(<span class="number">0</span>, <span class="attr">Math</span>::max);</span><br><span class="line">    <span class="comment">// reduce实现数据的处理</span></span><br><span class="line">    System.out.println(maxAge);</span><br><span class="line">    <span class="comment">// 3.统计 字符 a 出现的次数</span></span><br><span class="line">    Integer count = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>)</span><br><span class="line">            .map(ch -&gt; <span class="string">"a"</span>.equals(ch) ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            .reduce(<span class="number">0</span>, <span class="attr">Integer</span>::sum);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-14-mapToInt"><a href="#4-14-mapToInt" class="headerlink" title="4.14 mapToInt"></a>4.14 mapToInt</h6><p>如果需要将Stream中的Integer类型转换成int类型，可以使用mapToInt方法来实现<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/3c973edcc51f4bbfb63dbd1ed601def6.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// Integer占用的内存比int多很多，在Stream流操作中会自动装修和拆箱操作</span></span><br><span class="line">    Integer arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    Stream.of(arr).filter(i -&gt; i &gt; <span class="number">0</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">    <span class="comment">// 为了提高程序代码的效率，我们可以先将流中Integer数据转换为int数据，然后再操作</span></span><br><span class="line">    IntStream intStream = Stream.of(arr).mapToInt(Integer::intValue);</span><br><span class="line">    intStream.filter(i -&gt; i &gt; <span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-15-concat"><a href="#4-15-concat" class="headerlink" title="4.15 concat"></a>4.15 concat</h6><p>如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123;</span><br><span class="line">      Objects.requireNonNull(a);</span><br><span class="line">      Objects.requireNonNull(b);</span><br><span class="line"></span><br><span class="line">      @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">      Spliterator&lt;T&gt; split = <span class="keyword">new</span> Streams.ConcatSpliterator.OfRef&lt;&gt;(</span><br><span class="line">              (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());</span><br><span class="line">      Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());</span><br><span class="line">      <span class="keyword">return</span> stream.onClose(Streams.composedClose(a, b));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Stream&lt;<span class="built_in">String</span>&gt; stream1 = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    Stream&lt;<span class="built_in">String</span>&gt; stream2 = Stream.of(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>);</span><br><span class="line">    <span class="comment">// 通过concat方法将两个流合并为一个新的流</span></span><br><span class="line">    Stream.concat(stream1, stream2)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-16-综合案例"><a href="#4-16-综合案例" class="headerlink" title="4.16 综合案例"></a>4.16 综合案例</h6><p>定义两个集合，然后在集合中存储多个用户名称。然后完成如下的操作：</p>
<ol>
<li>第一个队伍只保留姓名长度为3的成员</li>
<li>第一个队伍筛选之后只要前3个人</li>
<li>第二个队伍只要姓张的成员</li>
<li>第二个队伍筛选之后不要前两个人</li>
<li>将两个队伍合并为一个队伍</li>
<li>根据姓名创建Person对象</li>
<li>打印整个队伍的Person信息</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="built_in">String</span>&gt; list1 = Arrays.asList(<span class="string">"迪丽热巴"</span>, <span class="string">"宋远桥"</span>, <span class="string">"苏星河"</span>, <span class="string">"老子"</span>, <span class="string">"庄子"</span>, <span class="string">"孙子"</span>, <span class="string">"洪七公公"</span>);</span><br><span class="line">        List&lt;<span class="built_in">String</span>&gt; list2 = Arrays.asList(<span class="string">"古力娜扎"</span>, <span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"赵丽颖"</span>, <span class="string">"张二狗"</span>, <span class="string">"张天爱"</span>, <span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. 第一个队伍只保留姓名长度为3的成员</span></span><br><span class="line">        list1.stream().filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------2"</span>);</span><br><span class="line"><span class="comment">//        2. 第一个队伍筛选之后只要前3个人</span></span><br><span class="line">        list1.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//        3. 第二个队伍只要姓张的成员</span></span><br><span class="line">        System.out.println(<span class="string">"-------------3"</span>);</span><br><span class="line">        list2.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"><span class="comment">//        4. 第二个队伍筛选之后不要前两个人</span></span><br><span class="line">        System.out.println(<span class="string">"-------------4"</span>);</span><br><span class="line"></span><br><span class="line">        list2.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"><span class="comment">//        5. 将两个队伍合并为一个队伍</span></span><br><span class="line"><span class="comment">//        6. 根据姓名创建Person对象</span></span><br><span class="line"><span class="comment">//        7. 打印整个队伍的Person信息</span></span><br><span class="line">        Stream.concat(list1.stream(),list2.stream())</span><br><span class="line">         .map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-Stream结果收集"><a href="#5-Stream结果收集" class="headerlink" title="5.Stream结果收集"></a>5.Stream结果收集</h4><h6 id="5-1-结果收集到集合中"><a href="#5-1-结果收集到集合中" class="headerlink" title="5.1 结果收集到集合中"></a>5.1 结果收集到集合中</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">        <span class="comment">// 收集到List</span></span><br><span class="line">        List&lt;<span class="built_in">String</span>&gt; list = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集到 Set集合中</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="keyword">set</span> = Stream.of("aa", "bb", "cc", "aa")</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(<span class="keyword">set</span>);</span><br><span class="line">        // 如果需要获取的类型为具体的实现，比如：ArrayList HashSet</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = Stream.of("aa", "bb", "cc", "aa")</span><br><span class="line">//        .collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;()));</span><br><span class="line">                .collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        </span><br><span class="line">        HashSet&lt;String&gt; hashSet = Stream.of("aa", "bb", "cc", "aa")</span><br><span class="line">                .collect(Collectors.toCollection(HashSet::new));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-2-结果收集到数组中"><a href="#5-2-结果收集到数组中" class="headerlink" title="5.2 结果收集到数组中"></a>5.2 结果收集到数组中</h6><p>Stream中提供了toArray方法来将结果放到一个数组中，返回值类型是Object[],如果我们要指定返回的类型，那么可以使用另一个重载的toArray(IntFunction f)方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">    <span class="built_in">Object</span>[] objects = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>).toArray();</span><br><span class="line">    <span class="comment">// 返回的数组中的元素是 Object类型</span></span><br><span class="line">    System.out.println(Arrays.toString(objects));</span><br><span class="line">    <span class="comment">// 如果我们需要指定返回的数组中的元素类型</span></span><br><span class="line">    <span class="built_in">String</span>[] strings = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>)</span><br><span class="line">            .toArray(<span class="built_in">String</span>[]::<span class="keyword">new</span>);</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-3-对流中的数据做聚合计算"><a href="#5-3-对流中的数据做聚合计算" class="headerlink" title="5.3 对流中的数据做聚合计算"></a>5.3 对流中的数据做聚合计算</h6><p>当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作，比如获得最大值，最小值，求和，平均值，统计数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   public <span class="keyword">void</span> test03() &#123;</span><br><span class="line">       <span class="comment">// 获取年龄的最大值</span></span><br><span class="line">        Optional&lt;Person&gt; maxAge = Stream.of(</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>))</span><br><span class="line">               .collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">       System.out.println(<span class="string">"最大年龄："</span> + maxAge.get());</span><br><span class="line">       <span class="comment">// 获取年龄的最小值</span></span><br><span class="line">       Optional&lt;Person&gt; minAge = Stream.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>))</span><br><span class="line">               .collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">       System.out.println(<span class="string">"最新年龄:"</span> + minAge.get());</span><br><span class="line">       <span class="comment">// 求所有人的年龄之和</span></span><br><span class="line">       Integer sumAge = Stream.of(</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>))</span><br><span class="line">               <span class="comment">//.collect(Collectors.summingInt(s -&gt; s.getAge()))</span></span><br><span class="line">               .collect(Collectors.summingInt(Person::getAge));</span><br><span class="line">       System.out.println(<span class="string">"年龄总和："</span> + sumAge);</span><br><span class="line">       <span class="comment">// 年龄的平均值</span></span><br><span class="line">       Double avgAge = Stream.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">               <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>), <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>)).collect(Collectors.averagingInt(Person::getAge));</span><br><span class="line">       System.out.println(<span class="string">"年龄的平均值："</span> + avgAge);</span><br><span class="line">       <span class="comment">// 统计数量</span></span><br><span class="line">       Long count = Stream.of(</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">13</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>),</span><br><span class="line">                       <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>)).</span><br><span class="line">               filter(p -&gt; p.getAge() &gt; <span class="number">18</span>)</span><br><span class="line">               .collect(Collectors.counting());</span><br><span class="line">       System.out.println(<span class="string">"满足条件的记录数:"</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-4-对流中数据做分组操作"><a href="#5-4-对流中数据做分组操作" class="headerlink" title="5.4 对流中数据做分组操作"></a>5.4 对流中数据做分组操作</h6><p>当我们使用Stream流处理数据后，可以根据某个属性将数据分组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test04() &#123;</span><br><span class="line">    <span class="comment">// 根据账号对数据进行分组</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, List&lt;Person&gt;&gt; map1 = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>))</span><br><span class="line">            .collect(Collectors</span><br><span class="line">                    .groupingBy(Person::getName));</span><br><span class="line"></span><br><span class="line">    map1.forEach((k, v) -&gt;</span><br><span class="line">            System.out.println(<span class="string">"k="</span> + k + <span class="string">"\t"</span> + <span class="string">"v="</span> + v));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据年龄分组 如果大于等于18 成年否则未成年</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, List&lt;Person&gt;&gt; map2 = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>))</span><br><span class="line">            .collect(Collectors.groupingBy(p -&gt; p.getAge() &gt;= <span class="number">18</span> ? <span class="string">"成年"</span> : <span class="string">"未成 年"</span>));</span><br><span class="line"></span><br><span class="line">    map2.forEach((k, v) -&gt; System.out.println(<span class="string">"k="</span> + k + <span class="string">"\t"</span> + <span class="string">"v="</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多级分组: 先根据name分组然后根据年龄分组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test05() &#123;</span><br><span class="line">    <span class="comment">// 先根据name分组，然后根据age(成年和未成年)分组</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, List&lt;Person&gt;&gt;&gt; map = Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">                     <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">12</span>, <span class="number">137</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>)).</span><br><span class="line">            collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                    Collectors.groupingBy(p -&gt; p.getAge() &gt;= <span class="number">18</span> ? <span class="string">"成年"</span> : <span class="string">"未成年"</span>)));</span><br><span class="line">    map.forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">        v.forEach((k1, v1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"\t"</span> + k1 + <span class="string">"="</span> + v1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">李四</span><br><span class="line">	未成年=[Person(name=李四, age=<span class="number">12</span>, height=<span class="number">137</span>), Person(name=李四, age=<span class="number">15</span>, height=<span class="number">166</span>)]</span><br><span class="line">	成年=[Person(name=李四, age=<span class="number">22</span>, height=<span class="number">177</span>)]</span><br><span class="line">张三</span><br><span class="line">	未成年=[Person(name=张三, age=<span class="number">14</span>, height=<span class="number">165</span>)]</span><br><span class="line">	成年=[Person(name=张三, age=<span class="number">18</span>, height=<span class="number">175</span>), Person(name=张三, age=<span class="number">19</span>, height=<span class="number">182</span>)]</span><br></pre></td></tr></table></figure>
<h6 id="5-5-对流中的数据做分区操作"><a href="#5-5-对流中的数据做分区操作" class="headerlink" title="5.5 对流中的数据做分区操作"></a>5.5 对流中的数据做分区操作</h6><p>Collectors.partitioningBy会根据值是否为true,把集合中的数据分割为两个列表，一个true列表，一个false列表</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/0e794e496abc48f6ae7dae604582054f.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 分区操作 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test06() &#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, List&lt;Person&gt;&gt; map = Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>))</span><br><span class="line">            .collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; <span class="number">18</span>));</span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>	[Person(name=张三, age=<span class="number">18</span>, height=<span class="number">175</span>), Person(name=张三, age=<span class="number">14</span>, height=<span class="number">165</span>), Person(name=李四, age=<span class="number">15</span>, height=<span class="number">166</span>)]</span><br><span class="line"><span class="literal">true</span>	[Person(name=李四, age=<span class="number">22</span>, height=<span class="number">177</span>), Person(name=张三, age=<span class="number">19</span>, height=<span class="number">182</span>)]</span><br></pre></td></tr></table></figure>
<h6 id="5-6-对流中的数据做拼接"><a href="#5-6-对流中的数据做拼接" class="headerlink" title="5.6 对流中的数据做拼接"></a>5.6 对流中的数据做拼接</h6><p>Collectors.joining会根据指定的连接符，将所有的元素连接成一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test07() &#123;</span><br><span class="line">    <span class="built_in">String</span> s1 = Stream.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>), <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>), <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>)).map(Person::getName).collect(Collectors.joining());</span><br><span class="line">    <span class="comment">// 张三李四张三李四张三</span></span><br><span class="line">    System.out.println(s1);</span><br><span class="line">    <span class="built_in">String</span> s2 = Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>))</span><br><span class="line">            .map(Person::getName)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">"_"</span>));</span><br><span class="line">    <span class="comment">// 张三_李四_张三_李四_张三</span></span><br><span class="line">    System.out.println(s2);</span><br><span class="line">    <span class="built_in">String</span> s3 = Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">175</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="number">177</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">14</span>, <span class="number">165</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">15</span>, <span class="number">166</span>),</span><br><span class="line">                    <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">19</span>, <span class="number">182</span>))</span><br><span class="line">            .map(Person::getName).collect(Collectors</span><br><span class="line">                    .joining(<span class="string">"_"</span>, <span class="string">"###"</span>, <span class="string">"$$$"</span>));</span><br><span class="line">    <span class="comment">// ###张三_李四_张三_李四_张三$$$</span></span><br><span class="line">    System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-并行的Stream流"><a href="#6-并行的Stream流" class="headerlink" title="6. 并行的Stream流"></a>6. 并行的Stream流</h5><h6 id="6-1-串行的Stream流"><a href="#6-1-串行的Stream流" class="headerlink" title="6.1 串行的Stream流"></a>6.1 串行的Stream流</h6><p>我们前面使用的Stream流都是串行，也就是在一个线程上面执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test08() &#123;</span><br><span class="line">    Stream.of(<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>).filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">""</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">5</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">6</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">8</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">3</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">1</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h6 id="6-2-并行流"><a href="#6-2-并行流" class="headerlink" title="6.2 并行流"></a>6.2 并行流</h6><p>parallelStream其实就是一个并行执行的流，它通过默认的ForkJoinPool，可以提高多线程任务的速度。<br><strong>6.2.1 获取并行流</strong><br>我们可以通过两种方式来获取并行流。</p>
<ol>
<li>通过List接口中的parallelStream方法来获取</li>
<li>通过已有的串行流转换为并行流(parallel)</li>
</ol>
<p><strong>6.2.2 并行流操作</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test10() &#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>).parallel()</span><br><span class="line">            <span class="comment">// 将流转换为并发流，Stream处理的时候就会通过多线程处理</span></span><br><span class="line">            .filter(s -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" s="</span> + s);</span><br><span class="line">                <span class="keyword">return</span> s &gt; <span class="number">2</span>;</span><br><span class="line">            &#125;).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-9</span>,<span class="number">5</span>,main] s=<span class="number">5</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-11</span>,<span class="number">5</span>,main] s=<span class="number">1</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-5</span>,<span class="number">5</span>,main] s=<span class="number">4</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-3</span>,<span class="number">5</span>,main] s=<span class="number">9</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-15</span>,<span class="number">5</span>,main] s=<span class="number">2</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main] s=<span class="number">1</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker<span class="number">-7</span>,<span class="number">5</span>,main] s=<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h6 id="6-3-并行流和串行流对比"><a href="#6-3-并行流和串行流对比" class="headerlink" title="6.3 并行流和串行流对比"></a>6.3 并行流和串行流对比</h6><p>我们通过for循环，串行Stream流，并行Stream流来对500000000亿个数字求和。来看消耗时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> long times = <span class="number">500000000</span>;</span><br><span class="line">    private long start;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public <span class="keyword">void</span> befor() &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public <span class="keyword">void</span> end() &#123;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"消耗时间："</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 普通for循环 消耗时间：258 */</span></span><br><span class="line">    @Test</span><br><span class="line">    public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">        System.out.println(<span class="string">"普通for循环:"</span>);</span><br><span class="line">        long res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 串行流处理 * 消耗时间：200 */</span></span><br><span class="line">    @Test</span><br><span class="line">    public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">        System.out.println(<span class="string">"串行流：serialStream"</span>);</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>, times)</span><br><span class="line">                .reduce(<span class="number">0</span>, <span class="attr">Long</span>::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 并行流处理 消耗时间：107 */</span></span><br><span class="line">    @Test</span><br><span class="line">    public <span class="keyword">void</span> test03() &#123;</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>, times).parallel()</span><br><span class="line">                .reduce(<span class="number">0</span>, <span class="attr">Long</span>::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过案例我们可以看到parallelStream的效率是最高的。<br>Stream并行处理的过程会分而治之，也就是将一个大的任务切分成了多个小任务，这表示每个任务都是一个线程操作。</p>
<h6 id="6-4-线程安全问题"><a href="#6-4-线程安全问题" class="headerlink" title="6.4 线程安全问题"></a>6.4 线程安全问题</h6><p>在多线程的处理下，肯定会出现数据安全问题。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用并行流来向集合中添加数据</span></span><br><span class="line">    list.parallelStream()</span><br><span class="line">            <span class="comment">//.forEach(s-&gt;listNew.add(s));</span></span><br><span class="line">            .forEach(listNew::add);</span><br><span class="line">    System.out.println(listNew.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">934</span></span><br></pre></td></tr></table></figure>

<p>针对这个问题，我们的解决方案有哪些呢？</p>
<ol>
<li>加同步锁</li>
<li>使用线程安全的容器</li>
<li>通过Stream中的toArray/collect操作<br>实现：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).parallel()</span><br><span class="line">            .forEach(i -&gt; &#123;</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    listNew.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(listNew.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 将线程不安全的容器转换为线程安全的容器 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test04() &#123;</span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将线程不安全的容器包装为线程安全的容器</span></span><br><span class="line">    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(listNew);</span><br><span class="line">    <span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).parallel().forEach(i -&gt; &#123;</span><br><span class="line">        synchronizedList.add(i);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(synchronizedList.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 使用线程安全的容器 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test03() &#123;</span><br><span class="line">    Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).parallel().forEach(i -&gt; &#123;</span><br><span class="line">        synchronized (obj) &#123;</span><br><span class="line">            v.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(v.size());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*** 我们还可以通过Stream中的 toArray方法或者 collect方法来操作 * 就是满足线程安全的要求 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test05() &#123;</span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel().boxed().collect(Collectors.toList());</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、Optional类"><a href="#七、Optional类" class="headerlink" title="七、Optional类"></a>七、Optional类</h2><p>这个Optional类注意是解决空指针的问题</p>
<h4 id="1-以前对null-的处理"><a href="#1-以前对null-的处理" class="headerlink" title="1. 以前对null 的处理"></a>1. 以前对null 的处理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    <span class="comment">//String userName = "张三";</span></span><br><span class="line">    <span class="built_in">String</span> userName = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"字符串的长度："</span> + userName.length());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"字符串为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Optional类"><a href="#2-Optional类" class="headerlink" title="2. Optional类"></a>2. Optional类</h4><p>Optional是一个没有子类的工具类，Optional是一个可以为null的容器对象，它的主要作用就是为了避免Null检查，防止NullpointerException，<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/52a479cf1065437ca18a63cc413a6515.png" alt="在这里插入图片描述"></p>
<h4 id="3-Optional的基本使用"><a href="#3-Optional的基本使用" class="headerlink" title="3. Optional的基本使用"></a>3. Optional的基本使用</h4><p>Optional对象的创建方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">    <span class="comment">// 第一种方式 通过of方法 of方法是不支持null的</span></span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op1 = Optional.of(<span class="string">"zhangsan"</span>);</span><br><span class="line">    <span class="comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span></span><br><span class="line">    <span class="comment">// 第二种方式通过 ofNullable方法 支持null</span></span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op3 = Optional.ofNullable(<span class="string">"lisi"</span>);</span><br><span class="line">    Optional&lt;<span class="built_in">Object</span>&gt; op4 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 第三种方式 通过empty方法直接创建一个空的Optional对象</span></span><br><span class="line">    Optional&lt;<span class="built_in">Object</span>&gt; op5 = Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Optional的常用方法"><a href="#4-Optional的常用方法" class="headerlink" title="4. Optional的常用方法"></a>4. Optional的常用方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Optional中的常用方法介绍</span></span><br><span class="line"><span class="comment"> * get(): 如果Optional有值则返回，否则抛出NoSuchElementException异常</span></span><br><span class="line"><span class="comment"> * get()通常和isPresent方法一块使用</span></span><br><span class="line"><span class="comment"> * isPresent():判断是否包含值，包含值返回true，不包含值返回false</span></span><br><span class="line"><span class="comment"> * orElse(T t):如果调用对象包含值，就返回该值，否则返回t</span></span><br><span class="line"><span class="comment"> * orElseGet(Supplier s):如果调用对象包含值，就返回该值，否则返回 Lambda表达式的返 回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test03() &#123;</span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op1 = Optional.of(<span class="string">"zhangsan"</span>);</span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op2 = Optional.empty();</span><br><span class="line">    <span class="comment">// 获取Optional中的值</span></span><br><span class="line">    <span class="keyword">if</span> (op1.isPresent()) &#123;</span><br><span class="line">        <span class="built_in">String</span> s1 = op1.get();</span><br><span class="line">        System.out.println(<span class="string">"用户名称:"</span> + s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op2.isPresent()) &#123;</span><br><span class="line">        System.out.println(op2.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"op2是一个空Optional对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span> s3 = op1.orElse(<span class="string">"李四"</span>);</span><br><span class="line">    System.out.println(s3);</span><br><span class="line">    <span class="built_in">String</span> s4 = op2.orElse(<span class="string">"王五"</span>);</span><br><span class="line">    System.out.println(s4);</span><br><span class="line">    <span class="built_in">String</span> s5 = op2.orElseGet(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(s5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test04() &#123;</span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op1 = Optional.of(<span class="string">"zhangsan"</span>);</span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; op2 = Optional.empty();</span><br><span class="line">    <span class="comment">// 如果存在值 就做什么</span></span><br><span class="line">    op1.ifPresent(s -&gt; System.out.println(<span class="string">"有值:"</span> + s));</span><br><span class="line">    op1.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 自定义一个方法，将Person对象中的 name 转换为大写 并返回 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test05() &#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">18</span>);</span><br><span class="line">    Optional&lt;Person&gt; op = Optional.of(p);</span><br><span class="line">    <span class="built_in">String</span> name = getNameForOptional(op);</span><br><span class="line">    System.out.println(<span class="string">"name="</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 根据Person对象 将name转换为大写并返回 * 通过Optional方式实现 * <span class="doctag">@param </span>op * <span class="doctag">@return </span>*/</span></span><br><span class="line">public <span class="built_in">String</span> getNameForOptional(Optional&lt;Person&gt; op) &#123;</span><br><span class="line">    <span class="keyword">if</span> (op.isPresent()) &#123;</span><br><span class="line">        <span class="built_in">String</span> msg = <span class="comment">//op.map(p -&gt; p.getName())</span></span><br><span class="line">                op.map(Person::getName)</span><br><span class="line">                        <span class="comment">//.map(p -&gt; p.toUpperCase())</span></span><br><span class="line">                        .map(<span class="built_in">String</span>::toUpperCase).orElse(<span class="string">"空值"</span>);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 根据Person对象 将name转换为大写并返回 * <span class="doctag">@param </span>person * <span class="doctag">@return </span>*/</span></span><br><span class="line">public <span class="built_in">String</span> getName(Person person) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">String</span> name = person.getName();</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、新时间日期API"><a href="#八、新时间日期API" class="headerlink" title="八、新时间日期API"></a>八、新时间日期API</h2><h4 id="1-旧版日期时间的问题"><a href="#1-旧版日期时间的问题" class="headerlink" title="1.旧版日期时间的问题"></a>1.旧版日期时间的问题</h4><p>在旧版本中JDK对于日期和时间这块的时间是非常差的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test01() throws Exception &#123;</span><br><span class="line">    <span class="comment">// 1.设计不合理</span></span><br><span class="line">    <span class="built_in">Date</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2021</span>, <span class="number">05</span>, <span class="number">05</span>);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.时间格式化和解析操作是线程不安全的</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// System.out.println(sdf.format(date));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(sdf.parse(<span class="string">"2021-05-06"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>设计不合理，在java.util和java.sql的包中都有日期类，java.util.Date同时包含日期和时间的，而java.sql.Date仅仅包含日期，此外用于格式化和解析的类在java.text包下。</li>
<li>非线程安全，java.util.Date是非线程安全的，所有的日期类都是可变的，这是java日期类最大的问题之一。</li>
<li>时区处理麻烦，日期类并不提供国际化，没有时区支持。<h4 id="2-新日期时间API介绍"><a href="#2-新日期时间API介绍" class="headerlink" title="2. 新日期时间API介绍"></a>2. 新日期时间API介绍</h4>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于<br>java.time 包中，下面是一些关键类。</li>
</ol>
<ul>
<li>LocalDate ：表示日期，包含年月日，格式为 2019-10-16</li>
<li>LocalTime ：表示时间，包含时分秒，格式为 16:38:54.158549300</li>
<li>LocalDateTime ：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</li>
<li>DateTimeFormatter ：日期时间格式化类。</li>
<li>Instant：时间戳，表示一个特定的时间瞬间。</li>
<li>Duration：用于计算2个时间(LocalTime，时分秒)的距离</li>
<li>Period：用于计算2个日期(LocalDate，年月日)的距离</li>
<li>ZonedDateTime ：包含时区的时间<br>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。此外Java 8还提供了4套其他历法，分别是：</li>
<li>ThaiBuddhistDate：泰国佛教历</li>
<li>MinguoDate：中华民国历</li>
<li>JapaneseDate：日本历</li>
<li>HijrahDate：伊斯兰历</li>
</ul>
<h6 id="2-1-日期时间的常见操作"><a href="#2-1-日期时间的常见操作" class="headerlink" title="2.1 日期时间的常见操作"></a>2.1 日期时间的常见操作</h6><p> LocalDate，LocalTime以及LocalDateTime的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** JDK8 日期时间操作 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    <span class="comment">// 1.创建指定的日期</span></span><br><span class="line">    LocalDate date1 = LocalDate.of(<span class="number">2021</span>, <span class="number">05</span>, <span class="number">06</span>);</span><br><span class="line">    System.out.println(<span class="string">"date1 = "</span> + date1);</span><br><span class="line">    <span class="comment">// 2.得到当前的日期</span></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">"now = "</span> + now);</span><br><span class="line">    <span class="comment">// 3.根据LocalDate对象获取对应的日期信息</span></span><br><span class="line">    System.out.println(<span class="string">"年："</span> + now.getYear());</span><br><span class="line">    System.out.println(<span class="string">"月："</span> + now.getMonth().getValue());</span><br><span class="line">    System.out.println(<span class="string">"日："</span> + now.getDayOfMonth());</span><br><span class="line">    System.out.println(<span class="string">"星期："</span> + now.getDayOfWeek().getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 时间操作 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">    <span class="comment">// 1.得到指定的时间</span></span><br><span class="line">    LocalTime time = LocalTime.of(<span class="number">5</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">23145</span>);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="comment">// 2.获取当前的时间</span></span><br><span class="line">    LocalTime now = LocalTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="comment">// 3.获取时间信息</span></span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">    System.out.println(now.getMinute());</span><br><span class="line">    System.out.println(now.getSecond());</span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 日期时间类型 LocalDateTime */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test03() &#123;</span><br><span class="line">    <span class="comment">// 获取指定的日期时间</span></span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.of(<span class="number">2020</span>, <span class="number">06</span>, <span class="number">01</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">33</span></span><br><span class="line">            , <span class="number">213</span>);</span><br><span class="line">    System.out.println(dateTime);</span><br><span class="line">    <span class="comment">// 获取当前的日期时间</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="comment">// 获取日期时间信息</span></span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    System.out.println(now.getMonth().getValue());</span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    System.out.println(now.getDayOfWeek().getValue());</span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">    System.out.println(now.getMinute());</span><br><span class="line">    System.out.println(now.getSecond());</span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="2-2-日期时间的修改和比较"><a href="#2-2-日期时间的修改和比较" class="headerlink" title="2.2 日期时间的修改和比较"></a>2.2 日期时间的修改和比较</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 日期时间的修改 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">"now = "</span> + now);</span><br><span class="line">    <span class="comment">// 修改日期时间 对日期时间的修改，对已存在的LocalDate对象，创建了它模板</span></span><br><span class="line">    <span class="comment">// 并不会修改原来的信息</span></span><br><span class="line">    LocalDateTime localDateTime = now.withYear(<span class="number">1998</span>);</span><br><span class="line">    System.out.println(<span class="string">"now :"</span> + now);</span><br><span class="line">    System.out.println(<span class="string">"修改后的："</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">"月份："</span> + now.withMonth(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">"天："</span> + now.withDayOfMonth(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">"小时："</span> + now.withHour(<span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">"分钟:"</span> + now.withMinute(<span class="number">15</span>));</span><br><span class="line">    <span class="comment">// 在当前日期时间的基础上 加上或者减去指定的时间</span></span><br><span class="line">    System.out.println(<span class="string">"两天后:"</span> + now.plusDays(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"10年后:"</span> + now.plusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">"6个月后 = "</span> + now.plusMonths(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">"10年前 = "</span> + now.minusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">"半年前 = "</span> + now.minusMonths(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">"一周前 = "</span> + now.minusDays(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 日期时间的比较 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test02() &#123;</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    LocalDate date = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 在JDK8中要实现 日期的比较 isAfter isBefore isEqual 通过这几个方法来直接比较</span></span><br><span class="line">    System.out.println(now.isAfter(date)); <span class="comment">// true</span></span><br><span class="line">     System.out.println(now.isBefore(date)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(now.isEqual(date)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：在进行日期时间修改的时候，原来的LocalDate对象是不会被修改，每次操作都是返回了一个新的LocalDate对象，所以在多线程场景下是数据安全的。</p>
<h4 id="2-3-格式化和解析操作"><a href="#2-3-格式化和解析操作" class="headerlink" title="2.3 格式化和解析操作"></a>2.3 格式化和解析操作</h4><p>在JDK8中我们可以通过 java.time.format.DateTimeFormatter 类可以进行日期的解析和格式化操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 指定格式 使用系统默认的格式 2021-05-27T16:16:38.139</span></span><br><span class="line">    DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">// 将日期时间转换为字符串</span></span><br><span class="line">    <span class="built_in">String</span> format = now.format(isoLocalDateTime);</span><br><span class="line">    System.out.println(<span class="string">"format = "</span> + format);</span><br><span class="line">    <span class="comment">// 通过 ofPattern 方法来指定特定的格式</span></span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy- MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="built_in">String</span> format1 = now.format(dateTimeFormatter);</span><br><span class="line">    <span class="comment">// 2021-05-27 16:16:38</span></span><br><span class="line">    System.out.println(<span class="string">"format1 = "</span> + format1);</span><br><span class="line">    <span class="comment">// 将字符串解析为一个 日期时间类型</span></span><br><span class="line">    LocalDateTime parse = LocalDateTime.parse(<span class="string">"1997-05-06 22:45:16"</span>, dateTimeFormatter);</span><br><span class="line">    <span class="comment">// parse = 1997-05-06T22:45:16</span></span><br><span class="line">    System.out.println(<span class="string">"parse = "</span> + parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-Instant类"><a href="#2-4-Instant类" class="headerlink" title="2.4 Instant类"></a>2.4 Instant类</h4><p>在JDK8中给我们新增一个Instant类(时间戳/时间线)，内部保存了从1970年1月1日 00:00:00以来的秒和纳秒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** Instant 时间戳 * 可以用来统计时间消耗 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() throws Exception &#123;</span><br><span class="line">    Instant now = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">"now = "</span> + now);</span><br><span class="line">    <span class="comment">// 获取从1970年一月一日 00:00:00 到现在的 纳秒</span></span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">    Thread.sleep(<span class="number">5</span>);</span><br><span class="line">    Instant now1 = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">"耗时："</span> + (now1.getNano() - now.getNano()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-计算日期时间差"><a href="#2-5-计算日期时间差" class="headerlink" title="2.5 计算日期时间差"></a>2.5 计算日期时间差</h4><p>JDK8中提供了两个工具类Duration/Period：计算日期时间差</p>
<ol>
<li>Duration：用来计算两个时间差(LocalTime)</li>
<li>Period:用来计算两个日期差(LocalDate)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 计算日期时间差 */</span></span><br><span class="line">   @Test</span><br><span class="line">   public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">       <span class="comment">// 计算时间差</span></span><br><span class="line">       LocalTime now = LocalTime.now();</span><br><span class="line">       LocalTime time = LocalTime.of(<span class="number">22</span>, <span class="number">48</span>, <span class="number">59</span>);</span><br><span class="line">       System.out.println(<span class="string">"now = "</span> + now);</span><br><span class="line">       <span class="comment">// 通过Duration来计算时间差</span></span><br><span class="line">       Duration duration = Duration.between(now, time);</span><br><span class="line">       System.out.println(duration.toDays()); <span class="comment">// 0</span></span><br><span class="line">       System.out.println(duration.toHours()); <span class="comment">// 7</span></span><br><span class="line">       System.out.println(duration.toMinutes()); <span class="comment">// 468</span></span><br><span class="line">       System.out.println(duration.toMillis()); <span class="comment">// 28028736</span></span><br><span class="line">       <span class="comment">// 计算日期差</span></span><br><span class="line">       LocalDate nowDate = LocalDate.now();</span><br><span class="line">       LocalDate date = LocalDate.of(<span class="number">1997</span>, <span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line">       Period period = Period.between(date, nowDate);</span><br><span class="line">       System.out.println(period.getYears()); <span class="comment">// 24</span></span><br><span class="line">       System.out.println(period.getMonths()); <span class="comment">// 5</span></span><br><span class="line">       System.out.println(period.getDays()); <span class="comment">// 44 &#125;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-时间校正器"><a href="#2-6-时间校正器" class="headerlink" title="2.6 时间校正器"></a>2.6 时间校正器</h4><p>有时候我们可以需要如下调整：将日期调整到”下个月的第一天”等操作。这时我们通过时间校正器效果可能会更好。</p>
<ul>
<li>TemporalAdjuster:时间校正器</li>
<li>TemporalAdjusters:通过该类静态方法提供了大量的常用TemporalAdjuster的实现。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 时间校正器 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 将当前的日期调整到下个月的一号</span></span><br><span class="line">    TemporalAdjuster adJuster = (temporal) -&gt; &#123;</span><br><span class="line">        LocalDateTime dateTime = (LocalDateTime) temporal;</span><br><span class="line">        LocalDateTime nextMonth = dateTime.plusMonths(<span class="number">1</span>).withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"nextMonth = "</span> + nextMonth);</span><br><span class="line">        <span class="keyword">return</span> nextMonth;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 我们可以通过TemporalAdjusters 来实现</span></span><br><span class="line">    <span class="comment">// LocalDateTime nextMonth = now.with(adJuster);</span></span><br><span class="line">    LocalDateTime nextMonth = now.with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">    System.out.println(<span class="string">"nextMonth = "</span> + nextMonth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-日期时间的时区"><a href="#2-7-日期时间的时区" class="headerlink" title="2.7 日期时间的时区"></a>2.7 日期时间的时区</h4><p> Java8 中加入了对时区的支持，LocalDate、LocalTime、LocalDateTime是不带时区的，带时区的日期时间类分别为：ZonedDate、ZonedTime、ZonedDateTime。其中每个时区都对应着 ID，ID的格式为 “区域/城市” 。例如 ：Asia/Shanghai 等。ZoneId：该类中包含了所有的时区信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 时区操作 */</span></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test01() &#123;</span><br><span class="line">    <span class="comment">// 1.获取所有的时区id</span></span><br><span class="line">    <span class="comment">//  ZoneId.getAvailableZoneIds().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// 获取当前时间 中国使用的 东八区的时区，比标准时间早8个小时</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">"now = "</span> + now); <span class="comment">// 2021-05-27T17:17:06.951</span></span><br><span class="line">    <span class="comment">// 获取标准时间</span></span><br><span class="line">    ZonedDateTime bz = ZonedDateTime.now(Clock.systemUTC());</span><br><span class="line">    System.out.println(<span class="string">"bz = "</span> + bz); <span class="comment">// 2021-05-27T09:17:06.952Z</span></span><br><span class="line">    <span class="comment">// 使用计算机默认的时区，创建日期时间</span></span><br><span class="line">    ZonedDateTime now1 = ZonedDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">"now1 = "</span> + now1); <span class="comment">//2021-05- 27T17:17:06.952+08:00[Asia/Shanghai]</span></span><br><span class="line">    <span class="comment">// 使用指定的时区创建日期时间</span></span><br><span class="line">    ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(<span class="string">"America/Marigot"</span>));</span><br><span class="line">    System.out.println(<span class="string">"now2 = "</span> + now2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK新的日期和时间API的优势：</p>
<ol>
<li>新版日期时间API中，日期和时间对象是不可变，操作日期不会影响原来的值，而是生成一个新的实例</li>
<li>提供不同的两种方式，有效的区分了人和机器的操作</li>
<li>TemporalAdjuster可以更精确的操作日期，还可以自定义日期调整期</li>
<li>线程安全</li>
</ol>
<h2 id="九、其他新特性"><a href="#九、其他新特性" class="headerlink" title="九、其他新特性"></a>九、其他新特性</h2><h4 id="1-重复注解"><a href="#1-重复注解" class="headerlink" title="1.重复注解"></a>1.重复注解</h4><p>有一个很大的限制是：在同一个地方不能多次使用同一个注解。JDK 8引入了重复注解的概念，允许在同一个地方多次使用同一个注解。在JDK 8中使用@Repeatable注解定义重复注解。</p>
<h6 id="1-1-定义一个重复注解的容器"><a href="#1-1-定义一个重复注解的容器" class="headerlink" title="1.1 定义一个重复注解的容器"></a>1.1 定义一个重复注解的容器</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">     MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-2-定义一个可以重复的注解"><a href="#1-2-定义一个可以重复的注解" class="headerlink" title="1.2 定义一个可以重复的注解"></a>1.2 定义一个可以重复的注解</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> value();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-3-配置多个重复的注解"><a href="#1-3-配置多个重复的注解" class="headerlink" title="1.3 配置多个重复的注解"></a>1.3 配置多个重复的注解</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(<span class="string">"test01"</span>)</span><br><span class="line">@MyAnnotation(<span class="string">"test02"</span>)</span><br><span class="line">@MyAnnotation(<span class="string">"test03"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AnnoTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @MyAnnotation(<span class="string">"fun1"</span>)</span><br><span class="line">    @MyAnnotation(<span class="string">"fun2"</span>)</span><br><span class="line">    public <span class="keyword">void</span> test01() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-4-解析得到指定的注解"><a href="#1-4-解析得到指定的注解" class="headerlink" title="1.4 解析得到指定的注解"></a>1.4 解析得到指定的注解</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 获取类中标注的重复注解</span></span><br><span class="line">    MyAnnotation[] annotationsByType = AnnoTest01.class.getAnnotationsByType(MyAnnotation.class);</span><br><span class="line">    <span class="keyword">for</span> (MyAnnotation myAnnotation : annotationsByType) &#123;</span><br><span class="line">        System.out.println(myAnnotation.value());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法上标注的重复注解</span></span><br><span class="line">        MyAnnotation[] test01s = AnnoTest01.class.getMethod(<span class="string">"test01"</span>).getAnnotationsByType(MyAnnotation.class);</span><br><span class="line">        <span class="keyword">for</span> (MyAnnotation test01 : test01s) &#123;</span><br><span class="line">            System.out.println(test01.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h4><p>JDK 8为@Target元注解新增了两种类型： TYPE_PARAMETER ， TYPE_USE 。</p>
<ul>
<li>TYPE_PARAMETER ：表示该注解能写在类型参数的声明语句中。 类型参数声明如： </li>
<li>TYPE_USE ：表示注解可以再任何用到类型的地方使用。<br>TYPE_PARAMETER</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE_PARAMETER) </span><br><span class="line">public @interface TypeParam &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TypeDemo01</span>&lt;@<span class="title">TypeParam</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    public &lt;@TypeParam K extends <span class="built_in">Object</span>&gt; K test01() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TYPE_USE</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE_USE) </span><br><span class="line">public @interface NotNull &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TypeUseDemo01</span> </span>&#123;</span><br><span class="line">    public @NotNull Integer age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    public Integer sum(@NotNull Integer a, @NotNull Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1442243445@qq.com">小小王</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2022/01/16/jdk18/">http://yoursite.com/2022/01/16/jdk18/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Wang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/jdk/">jdk</a></div><div class="post_share"><div class="social-share" data-image="/img/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/16/bk/"><img class="prev-cover" data-src="/img/bg.jpg" onerror="onerror=null;src='/'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">springclound</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/22/MyBatisPlus/"><img class="next-cover" data-src="/img/bg4.jpg" onerror="onerror=null;src='/'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatisPlus</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 小小王</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>粤ICP备20054751</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script src="js/move_mouse/script.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script src="/js/down_mouse/love.js"></script></body></html>